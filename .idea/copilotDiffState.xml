<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# AnyMeal - University Recipe Management App&#10;&#10;A modern Android application built with Kotlin and Jetpack Compose for managing recipes, meal planning, and shopping lists. This university project demonstrates clean architecture principles and modern Android development practices.&#10;&#10;## Features&#10;&#10;### ️ Core Functionality&#10;- **Recipe Discovery**: Browse and search through a comprehensive recipe database&#10;- **Meal Planning**: Plan weekly meals with an intuitive calendar interface&#10;- **Shopping Lists**: Generate and manage shopping lists based on planned meals&#10;- **Favorites**: Save and organize your favorite recipes&#10;- **Recipe Details**: View detailed cooking instructions, ingredients, and nutritional information&#10;&#10;###  User Experience&#10;- **User Authentication**: Secure login and registration system&#10;- **Profile Management**: Customize user profiles and preferences&#10;- **Achievements System**: Track cooking milestones and unlock achievements&#10;- **Dark/Light Theme**: Toggle between dark and light themes&#10;- **Search &amp; Filter**: Advanced recipe search with multiple filters&#10;&#10;###  Modern UI&#10;- Material Design 3 components&#10;- Smooth navigation with Jetpack Navigation Compose&#10;- Responsive layouts optimized for different screen sizes&#10;- Interactive components with smooth animations&#10;&#10;## Technologies Used&#10;&#10;### ️ Core Technologies&#10;- **Kotlin** - Primary programming language&#10;- **Jetpack Compose** - Modern UI toolkit for native Android&#10;- **Material Design 3** - Google's latest design system&#10;&#10;### ️ Architecture &amp; Libraries&#10;- **MVVM Architecture** - Clean separation of concerns&#10;- **Hilt** - Dependency injection framework&#10;- **Navigation Compose** - Type-safe navigation&#10;- **Retrofit** - HTTP client for API communication&#10;- **OkHttp** - Network interceptor and logging&#10;- **Coil** - Image loading library for Compose&#10;- **Gson** - JSON serialization/deserialization&#10;&#10;###  Development Tools&#10;- **Android Studio** - IDE&#10;- **Gradle** (Kotlin DSL) - Build system&#10;- **Kapt** - Kotlin annotation processing&#10;- **JUnit** - Unit testing framework&#10;- **Espresso** - UI testing framework&#10;&#10;## Architecture &amp; Folder Structure&#10;&#10;The app follows **MVVM (Model-View-ViewModel)** architecture with clean code principles:&#10;&#10;```&#10;app/src/main/java/com/noskill/anymeal/&#10;├── data/                    # Data layer (repositories, data sources)&#10;├── dto/                     # Data Transfer Objects&#10;├── navigation/              # Navigation setup and routes&#10;│   ├── AppNavGraph.kt      # Main navigation graph&#10;│   └── AppNavigation.kt    # Screen definitions and routes&#10;├── ui/                     # UI layer&#10;│   ├── components/         # Reusable UI components&#10;│   ├── models/            # UI models and state&#10;│   ├── screens/           # App screens/composables&#10;│   │   ├── AuthScreen.kt&#10;│   │   ├── HomeScreen.kt&#10;│   │   ├── PlanScreen.kt&#10;│   │   ├── RecipeDetailScreen.kt&#10;│   │   ├── RecipeSearchScreen.kt&#10;│   │   ├── ShoppingListScreen.kt&#10;│   │   ├── ProfileScreen.kt&#10;│   │   └── ...&#10;│   └── theme/             # App theming and styling&#10;├── util/                  # Utility classes and extensions&#10;├── viewmodel/            # ViewModels for business logic&#10;└── MainActivity.kt       # Main activity entry point&#10;```&#10;&#10;### Key Architectural Components&#10;- **Data Layer**: Handles API calls and data management&#10;- **ViewModel Layer**: Manages UI state and business logic&#10;- **UI Layer**: Compose screens and reusable components&#10;- **Navigation**: Type-safe navigation between screens&#10;- **Dependency Injection**: Hilt for managing dependencies&#10;&#10;## Installation &amp; Running&#10;&#10;### Prerequisites&#10;- **Android Studio** Hedgehog (2023.1.1) or later&#10;- **JDK 8** or higher&#10;- **Android SDK** (minimum API 26, target API 35)&#10;- **Git** for version control&#10;&#10;### Setup Instructions&#10;&#10;1. **Clone the repository**&#10;   ```bash&#10;   git clone &lt;repository-url&gt;&#10;   cd AnyMeal&#10;   ```&#10;&#10;2. **Open in Android Studio**&#10;   - Launch Android Studio&#10;   - Select &quot;Open an existing project&quot;&#10;   - Navigate to the cloned directory and select it&#10;&#10;3. **Sync Project**&#10;   - Android Studio will automatically prompt to sync Gradle&#10;   - Click &quot;Sync Now&quot; to download dependencies&#10;&#10;4. **Build the project**&#10;   ```bash&#10;   ./gradlew build&#10;   ```&#10;&#10;5. **Run on Emulator or Device**&#10;   - Connect an Android device or start an emulator&#10;   - Click the &quot;Run&quot; button in Android Studio&#10;   - Or use command line: `./gradlew installDebug`&#10;&#10;### Minimum Requirements&#10;- **Android 8.0** (API level 26) or higher&#10;- **2GB RAM** recommended&#10;- **Internet connection** for recipe data&#10;&#10;## Environment Variables / Configurations&#10;&#10;### Network Configuration&#10;The app requires internet connectivity for API calls. Network security is configured in:&#10;- `app/src/main/res/xml/network_security_config.xml`&#10;&#10;### API Configuration&#10;If using external APIs, configure endpoints in:&#10;- Create `local.properties` file (if not exists)&#10;- Add API keys or base URLs as needed:&#10;  ```properties&#10;  # Example configuration&#10;  API_BASE_URL=&quot;https://your-api-endpoint.com/&quot;&#10;  API_KEY=&quot;your-api-key-here&quot;&#10;  ```&#10;&#10;### Build Variants&#10;- **Debug**: Development build with logging enabled&#10;- **Release**: Production build with ProGuard optimization&#10;&#10;### Permissions&#10;The app requires the following permissions:&#10;- `INTERNET` - For API communication and image loading&#10;&#10;## Screenshots&#10;&#10;### Main Screens&#10;![Splash Screen](screenshots/splash_screen.png)&#10;*App splash screen with branding*&#10;&#10;![Home Screen](screenshots/home_screen.png)&#10;*Main dashboard with recipe recommendations*&#10;&#10;![Recipe Search](screenshots/recipe_search.png)&#10;*Search and filter recipes by various criteria*&#10;&#10;![Recipe Detail](screenshots/recipe_detail.png)&#10;*Detailed recipe view with ingredients and instructions*&#10;&#10;### Planning &amp; Organization&#10;![Meal Planning](screenshots/meal_planning.png)&#10;*Weekly meal planning interface*&#10;&#10;![Shopping List](screenshots/shopping_list.png)&#10;*Generated shopping list from planned meals*&#10;&#10;![Favorites](screenshots/favorites.png)&#10;*User's saved favorite recipes*&#10;&#10;### User Features&#10;![Profile Screen](screenshots/profile_screen.png)&#10;*User profile and settings*&#10;&#10;![Achievements](screenshots/achievements.png)&#10;*Cooking achievements and progress tracking*&#10;&#10;![Dark Theme](screenshots/dark_theme.png)&#10;*Dark theme variant of the app*&#10;&#10;---&#10;&#10;## Development Notes&#10;&#10;### Code Style&#10;- Follow Kotlin coding conventions&#10;- Use Compose best practices&#10;- Implement proper error handling&#10;- Write meaningful comments in Spanish (as per project requirements)&#10;&#10;### Testing&#10;- Unit tests in `src/test/`&#10;- UI tests in `src/androidTest/`&#10;- Run tests: `./gradlew test`&#10;&#10;### Contributing&#10;This is a university project. For educational purposes, ensure to:&#10;1. Follow clean architecture principles&#10;2. Write comprehensive documentation&#10;3. Implement proper error handling&#10;4. Use modern Android development practices&#10;&#10;---&#10;&#10;**Project Status**: Active Development  &#10;**Version**: 1.0  &#10;**Target SDK**: 35  &#10;**Minimum SDK**: 26  &#10;&#10;*Built with ❤️ using Kotlin and Jetpack Compose*" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/navigation/AppNavigation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/navigation/AppNavigation.kt" />
              <option name="updatedContent" value="/* --------------------------------------------------------------------&#10; * Archivo: AppNavigation.kt&#10; * Propósito: Define las rutas de navegación de la aplicación mediante la clase sellada Screen.&#10; *            Cada objeto representa una pantalla y su ruta asociada para el sistema de navegación.&#10; * --------------------------------------------------------------------*/&#10;&#10;package com.noskill.anymeal.navigation&#10;&#10;import java.net.URLEncoder&#10;import java.nio.charset.StandardCharsets&#10;&#10;// Clase sellada que representa cada pantalla de la app y su ruta de navegación.&#10;sealed class Screen(val route: String) {&#10;    object Splash : Screen(&quot;splash&quot;) // Pantalla de inicio&#10;    object Auth : Screen(&quot;auth&quot;) // Pantalla de autenticación&#10;    object Login : Screen(&quot;login&quot;) // Pantalla de inicio de sesión&#10;    object Register : Screen(&quot;register&quot;) // Pantalla de registro&#10;    object Home : Screen(&quot;home&quot;) // Pantalla principal&#10;    object Plan : Screen(&quot;plan&quot;) // Pantalla de planificación semanal&#10;    object ShoppingList : Screen(&quot;shopping_list&quot;) // Pantalla de lista de compras&#10;    object Profile : Screen(&quot;profile&quot;) // Pantalla de perfil de usuario&#10;    object Favorites : Screen(&quot;favorites&quot;) // Pantalla de favoritos&#10;    object PrivacyPolicy : Screen(&quot;privacy_policy&quot;) // Pantalla de política de privacidad&#10;    object Faq : Screen(&quot;faq&quot;) // Pantalla de preguntas frecuentes&#10;    object ContactUs : Screen(&quot;ContactUs&quot;) // Pantalla de contacto&#10;    object AppVersion : Screen(&quot;app_version&quot;) // Pantalla de versión de la app&#10;    object Achievements : Screen(&quot;achievements&quot;) // Pantalla de logros&#10;&#10;    object RecipeDetail : Screen(&quot;recipe_detail/{recipeId}?source={source}&amp;mealTime={mealTime}&quot;) {&#10;        fun createRoute(recipeId: Int, source: String? = null, mealTime: String? = null): String { // recipeId ya no es nullable aquí&#10;            val baseRoute = &quot;recipe_detail/$recipeId&quot; // Siempre pasa un Int&#10;            val sourceParam = source?.let { &quot;?source=$it&quot; } ?: &quot;&quot;&#10;            val encodedMealTime = mealTime?.let { URLEncoder.encode(it, StandardCharsets.UTF_8.toString()) } ?: &quot;&quot;&#10;            val mealTimeParam = if (mealTime != null) &quot;${if (sourceParam.isEmpty()) &quot;?&quot; else &quot;&amp;&quot;}mealTime=$encodedMealTime&quot; else &quot;&quot;&#10;            return &quot;$baseRoute$sourceParam$mealTimeParam&quot;&#10;        }&#10;    }&#10;&#10;    // MODIFICADO: Añadido {planDate} como argumento opcional para RecipeSearch&#10;    object RecipeSearch : Screen(&quot;recipe_search/{mealTime}?planDate={planDate}&quot;) {&#10;        fun createRoute(mealTime: String, planDate: String? = null): String {&#10;            val encodedMealTime = URLEncoder.encode(mealTime, StandardCharsets.UTF_8.toString())&#10;            val encodedPlanDate = planDate?.let { URLEncoder.encode(it, StandardCharsets.UTF_8.toString()) } ?: &quot;&quot;&#10;&#10;            var route = &quot;recipe_search/$encodedMealTime&quot;&#10;            if (planDate != null) {&#10;                route += &quot;?planDate=$encodedPlanDate&quot;&#10;            }&#10;            return route&#10;        }&#10;    }&#10;&#10;    object EditProfile : Screen(&quot;edit_profile&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/ui/screens/ShoppingListScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/ui/screens/ShoppingListScreen.kt" />
              <option name="originalContent" value="/**&#10; * ShoppingListScreen.kt&#10; * &#10; * Propósito: Define la pantalla de lista de compras de la aplicación AnyMeal.&#10; * Permite al usuario gestionar elementos de su lista de compras, incluyendo añadir,&#10; * editar, eliminar y marcar como completados. Ofrece funcionalidades de búsqueda,&#10; * filtrado por semana, y seguimiento del progreso de compra. Los elementos se&#10; * organizan por categorías para facilitar la experiencia de compra.&#10; */&#10;package com.noskill.anymeal.ui.screens&#10;&#10;import android.util.Log&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavController&#10;import androidx.navigation.NavGraph.Companion.findStartDestination&#10;import com.noskill.anymeal.data.navItems&#10;import com.noskill.anymeal.ui.components.FloatingBottomNavBar&#10;import com.noskill.anymeal.ui.components.WeekNavigator&#10;import com.noskill.anymeal.ui.models.ShoppingItem&#10;import com.noskill.anymeal.viewmodel.ShoppingListUiState&#10;import com.noskill.anymeal.viewmodel.ShoppingListViewModel&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;    // Mostrar mensajes de éxito con duración corta&#10;    LaunchedEffect(uiState.successMessage) {&#10;        uiState.successMessage?.let { successMessage -&gt;&#10;            snackbarHostState.showSnackbar(&#10;                message = successMessage,&#10;                duration = SnackbarDuration.Short  // Duración corta para mensajes de éxito&#10;            )&#10;            viewModel.clearError()&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(weekOffset) {&#10;        Log.d(&quot;ShoppingListVM&quot;, &quot; PANTALLA_INICIADA: weekOffset=$weekOffset&quot;)&#10;        if (weekOffset == 0) {&#10;            // Al cargar por primera vez o volver a la pantalla, usar getCurrentList&#10;            Log.d(&quot;ShoppingListVM&quot;, &quot; LLAMANDO getCurrentList() - primera carga&quot;)&#10;            viewModel.getCurrentList()&#10;        } else {&#10;            // Solo regenerar desde el plan cuando realmente cambiemos de semana&#10;            Log.d(&quot;ShoppingListVM&quot;, &quot; LLAMANDO generateListForWeek($weekOffset)&quot;)&#10;            viewModel.generateListForWeek(weekOffset)&#10;        }&#10;    }&#10;&#10;    val allItems = uiState.shoppingList.values.flatten()&#10;    val checkedItems = allItems.filter { it.isChecked }&#10;    val progress = if (allItems.isNotEmpty()) checkedItems.size.toFloat() / allItems.size.toFloat() else 0f&#10;&#10;    val filteredList = remember(searchQuery, uiState.shoppingList) {&#10;        if (searchQuery.isBlank()) {&#10;            uiState.shoppingList&#10;        } else {&#10;            uiState.shoppingList.mapValues { (_, items) -&gt;&#10;                items.filter { it.name.contains(searchQuery, ignoreCase = true) }&#10;            }.filter { it.value.isNotEmpty() }&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        Scaffold(&#10;            snackbarHost = { SnackbarHost(snackbarHostState) }&#10;        ) { innerPadding -&gt;&#10;            LazyColumn(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentPadding = PaddingValues(&#10;                    top = innerPadding.calculateTopPadding() + 16.dp,&#10;                    bottom = innerPadding.calculateBottomPadding() + 120.dp&#10;                ),&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                item {&#10;                    ShoppingListHeader(&#10;                        searchQuery = searchQuery,&#10;                        onSearchQueryChange = { searchQuery = it },&#10;                        checkedItems = checkedItems.size,&#10;                        totalItems = allItems.size,&#10;                        progress = progress&#10;                    )&#10;                }&#10;&#10;                item {&#10;                    val weekDateRange = remember(weekOffset) { getWeekDateRange(weekOffset) }&#10;                    WeekNavigator(&#10;                        weekDateRange = weekDateRange,&#10;                        onPreviousWeek = { weekOffset-- },&#10;                        onNextWeek = { weekOffset++ },&#10;                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                    )&#10;                }&#10;&#10;                when {&#10;                    uiState.isLoading -&gt; item { Box(Modifier.fillParentMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() } }&#10;                    uiState.error != null -&gt; item { Text(uiState.error!!, color = MaterialTheme.colorScheme.error, modifier = Modifier.padding(16.dp)) }&#10;                    filteredList.isEmpty() &amp;&amp; !uiState.isLoading -&gt; item { EmptyState(modifier = Modifier.padding(top = 60.dp)) }&#10;                    else -&gt; {&#10;                        filteredList.entries.forEach { (category, items) -&gt;&#10;                            stickyHeader {&#10;                                Text(&#10;                                    text = category,&#10;                                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold),&#10;                                    color = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(horizontal = 16.dp, vertical = 8.dp)&#10;                                )&#10;                            }&#10;                            items(items, key = { it.id }) { item -&gt;&#10;                                ShoppingListItemRow(&#10;                                    item = item,&#10;                                    onCheck = { viewModel.toggleItemChecked(item.id) },&#10;                                    onEdit = { selectedItem -&gt;&#10;                                        Log.d(&quot;ShoppingListScreen&quot;, &quot; EDIT_ITEM_ROW: itemId=${selectedItem.id}, name='${selectedItem.name}'&quot;)&#10;                                        itemToEdit = selectedItem&#10;                                        showEditItemDialog = true&#10;                                    },&#10;                                    onDelete = { selectedItem -&gt;&#10;                                        Log.d(&quot;ShoppingListScreen&quot;, &quot; DELETE_ITEM_ROW: itemId=${selectedItem.id}, name='${selectedItem.name}'&quot;)&#10;                                        viewModel.deleteItem(selectedItem.id)&#10;                                    },&#10;                                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        val selectedIndex = 2&#10;        FloatingBottomNavBar(&#10;            items = navItems,&#10;            selectedIndex = selectedIndex,&#10;            onItemSelected = { index -&gt;&#10;                val destination = navItems[index].route&#10;                if (navController.currentDestination?.route != destination) {&#10;                    navController.navigate(destination) {&#10;                        popUpTo(navController.graph.findStartDestination().id) { saveState = true }&#10;                        launchSingleTop = true&#10;                        restoreState = true&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.align(Alignment.BottomCenter)&#10;        )&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomEnd)&#10;                .padding(end = 16.dp, bottom = 96.dp)&#10;        ) {&#10;            Column(&#10;                verticalArrangement = Arrangement.spacedBy(8.dp),&#10;                horizontalAlignment = Alignment.End&#10;            ) {&#10;                // Botón de eliminar todos los marcados (solo aparece si hay items seleccionados)&#10;                if (checkedItems.isNotEmpty()) {&#10;                    FloatingActionButton(&#10;                        onClick = { viewModel.clearCheckedItems() },&#10;                        containerColor = MaterialTheme.colorScheme.errorContainer,&#10;                        contentColor = MaterialTheme.colorScheme.onErrorContainer,&#10;                        modifier = Modifier.size(48.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.DeleteSweep,&#10;                            contentDescription = &quot;Eliminar todos los marcados&quot;&#10;                        )&#10;                    }&#10;                }&#10;&#10;&#10;                // Botón de agregar (SIEMPRE visible)&#10;                FloatingActionButton(&#10;                    onClick = { showAddItemDialog = true },&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    contentColor = MaterialTheme.colorScheme.onPrimary&#10;                ) {&#10;                    Icon(imageVector = Icons.Default.Add, contentDescription = &quot;Añadir Ítem&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAddItemDialog) {&#10;        AddItemDialog(&#10;            onDismiss = { showAddItemDialog = false },&#10;            onConfirm = { name, quantity -&gt;&#10;                viewModel.addItem(name, quantity)&#10;                showAddItemDialog = false&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showEditItemDialog &amp;&amp; itemToEdit != null) {&#10;        val item = itemToEdit!!&#10;        EditItemDialog(&#10;            item = item,&#10;            onDismiss = {&#10;                showEditItemDialog = false&#10;                itemToEdit = null&#10;            },&#10;            onConfirm = { name, quantity -&gt;&#10;                viewModel.editItem(item.id, name, quantity)&#10;                showEditItemDialog = false&#10;                itemToEdit = null&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ShoppingListHeader(&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    checkedItems: Int,&#10;    totalItems: Int,&#10;    progress: Float&#10;) {&#10;    val animatedProgress by animateFloatAsState(targetValue = progress, label = &quot;progressAnimation&quot;)&#10;                )&#10;                Spacer(Modifier.height(8.dp))&#10;                LinearProgressIndicator(&#10;                    progress = { animatedProgress },&#10;                    modifier = Modifier.fillMaxWidth().height(8.dp).clip(RoundedCornerShape(4.dp)),&#10;                    strokeCap = StrokeCap.Round&#10;                )&#10;            }&#10;        }&#10;                unfocusedIndicatorColor = Color.Transparent,&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ShoppingListItemRow(&#10;    item: ShoppingItem,&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;                Text(&#10;                    text = item.name,&#10;                    textDecoration = textDecoration,&#10;                    color = textColor,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;                if (item.quantity.isNotBlank()) {&#10;                    Text(&#10;                        text = item.quantity,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = textColor.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Botones de acción directos en cada fila&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                // Botón Editar&#10;                        Icon(&#10;                            imageVector = Icons.Default.EditNote,&#10;                            contentDescription = &quot;Editar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary,&#10;                            modifier = Modifier.size(20.dp)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Botón Eliminar&#10;                Surface(&#10;                    onClick = {&#10;                        Log.d(&quot;ShoppingListScreen&quot;, &quot; DELETE_ITEM_ROW: itemId=${item.id}, name='${item.name}'&quot;)&#10;                        onDelete(item)&#10;                    },&#10;                    modifier = Modifier.size(36.dp),&#10;                    shape = RoundedCornerShape(8.dp),&#10;                    color = MaterialTheme.colorScheme.errorContainer.copy(alpha = 0.3f)&#10;                ) {&#10;                    Box(&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AddItemDialog(onDismiss: () -&gt; Unit, onConfirm: (name: String, quantity: String) -&gt; Unit) {&#10;    var name by remember { mutableStateOf(&quot;&quot;) }&#10;    var quantity by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Añadir Ítem Manualmente&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(value = name, onValueChange = { name = it }, label = { Text(&quot;Nombre del ítem&quot;) })&#10;                OutlinedTextField(value = quantity, onValueChange = { quantity = it }, label = { Text(&quot;Cantidad (ej: 2 tazas)&quot;) })&#10;            }&#10;        },&#10;        confirmButton = { Button(onClick = { onConfirm(name, quantity) }, enabled = name.isNotBlank()) { Text(&quot;Añadir&quot;) } },&#10;        dismissButton = { TextButton(onClick = onDismiss) { Text(&quot;Cancelar&quot;) } }&#10;    )&#10;}&#10;&#10;@Composable&#10;private fun EditItemDialog(item: ShoppingItem, onDismiss: () -&gt; Unit, onConfirm: (name: String, quantity: String) -&gt; Unit) {&#10;    var name by remember { mutableStateOf(item.name) }&#10;    var quantity by remember { mutableStateOf(item.quantity) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Editar Ítem&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(value = name, onValueChange = { name = it }, label = { Text(&quot;Nombre del ítem&quot;) })&#10;                OutlinedTextField(value = quantity, onValueChange = { quantity = it }, label = { Text(&quot;Cantidad (ej: 2 tazas)&quot;) })&#10;            }&#10;    Column(&#10;        modifier = modifier.fillMaxSize().padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Filled.ShoppingCart,&#10;            contentDescription = null,&#10;            modifier = Modifier.size(80.dp),&#10;            tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)&#10;        )&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;        Text(&quot;Tu lista está vacía&quot;, style = MaterialTheme.typography.headlineSmall)&#10;        Text(&quot;Genera una lista desde tu plan o añade ítems manualmente.&quot;, textAlign = androidx.compose.ui.text.style.TextAlign.Center)&#10;    }&#10;}&#10;&#10;private fun getWeekDateRange(weekOffset: Int): String {&#10;    val weekFormat = SimpleDateFormat(&quot;d MMM&quot;, Locale(&quot;es&quot;, &quot;ES&quot;))&#10;" />
              <option name="updatedContent" value="/**&#10; * ShoppingListScreen.kt&#10; * &#10; * Propósito: Define la pantalla de lista de compras de la aplicación AnyMeal.&#10; * Permite al usuario gestionar elementos de su lista de compras, incluyendo añadir,&#10; * editar, eliminar y marcar como completados. Ofrece funcionalidades de búsqueda,&#10; * filtrado por semana, y seguimiento del progreso de compra. Los elementos se&#10; * organizan por categorías para facilitar la experiencia de compra.&#10; */&#10;package com.noskill.anymeal.ui.screens&#10;&#10;import android.util.Log&#10;import androidx.compose.animation.AnimatedContent&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavController&#10;import androidx.navigation.NavGraph.Companion.findStartDestination&#10;import com.noskill.anymeal.data.navItems&#10;import com.noskill.anymeal.ui.components.FloatingBottomNavBar&#10;import com.noskill.anymeal.ui.components.WeekNavigator&#10;import com.noskill.anymeal.ui.models.ShoppingItem&#10;import com.noskill.anymeal.viewmodel.ShoppingListUiState&#10;import com.noskill.anymeal.viewmodel.ShoppingListViewModel&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;/**&#10; * Composable principal que define la pantalla de lista de compras.&#10; * Gestiona la visualización y manipulación de elementos de compra, incluyendo&#10; * búsqueda, filtrado por semana, y funcionalidades CRUD (crear, leer, actualizar, eliminar).&#10; * Implementa diálogos para añadir y editar elementos, y muestra el progreso de compra.&#10; * &#10; * @param navController Controlador de navegación para gestionar la navegación entre pantallas&#10; * @param viewModel ViewModel que maneja la lógica y datos de la lista de compras&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class)&#10;@Composable&#10;fun ShoppingListScreen(&#10;    navController: NavController,&#10;    viewModel: ShoppingListViewModel = viewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    var weekOffset by remember { mutableStateOf(0) }&#10;    var showAddItemDialog by remember { mutableStateOf(false) }&#10;    var showEditItemDialog by remember { mutableStateOf(false) }&#10;    var itemToEdit by remember { mutableStateOf&lt;ShoppingItem?&gt;(null) }&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Mostrar errores con Snackbar&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let { errorMessage -&gt;&#10;            snackbarHostState.showSnackbar(&#10;                message = errorMessage,&#10;                duration = SnackbarDuration.Long&#10;            )&#10;            // Limpiar el error después de mostrarlo&#10;            viewModel.clearError()&#10;        }&#10;    }&#10;&#10;    // Mostrar mensajes de éxito con duración corta&#10;    LaunchedEffect(uiState.successMessage) {&#10;        uiState.successMessage?.let { successMessage -&gt;&#10;            snackbarHostState.showSnackbar(&#10;                message = successMessage,&#10;                duration = SnackbarDuration.Short  // Duración corta para mensajes de éxito&#10;            )&#10;            viewModel.clearError()&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(weekOffset) {&#10;        Log.d(&quot;ShoppingListVM&quot;, &quot; PANTALLA_INICIADA: weekOffset=$weekOffset&quot;)&#10;        if (weekOffset == 0) {&#10;            // Al cargar por primera vez o volver a la pantalla, usar getCurrentList&#10;            Log.d(&quot;ShoppingListVM&quot;, &quot; LLAMANDO getCurrentList() - primera carga&quot;)&#10;            viewModel.getCurrentList()&#10;        } else {&#10;            // Solo regenerar desde el plan cuando realmente cambiemos de semana&#10;            Log.d(&quot;ShoppingListVM&quot;, &quot; LLAMANDO generateListForWeek($weekOffset)&quot;)&#10;            viewModel.generateListForWeek(weekOffset)&#10;        }&#10;    }&#10;&#10;    val allItems = uiState.shoppingList.values.flatten()&#10;    val checkedItems = allItems.filter { it.isChecked }&#10;    val progress = if (allItems.isNotEmpty()) checkedItems.size.toFloat() / allItems.size.toFloat() else 0f&#10;&#10;    val filteredList = remember(searchQuery, uiState.shoppingList) {&#10;        if (searchQuery.isBlank()) {&#10;            uiState.shoppingList&#10;        } else {&#10;            uiState.shoppingList.mapValues { (_, items) -&gt;&#10;                items.filter { it.name.contains(searchQuery, ignoreCase = true) }&#10;            }.filter { it.value.isNotEmpty() }&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        Scaffold(&#10;            snackbarHost = { SnackbarHost(snackbarHostState) }&#10;        ) { innerPadding -&gt;&#10;            LazyColumn(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentPadding = PaddingValues(&#10;                    top = innerPadding.calculateTopPadding() + 16.dp,&#10;                    bottom = innerPadding.calculateBottomPadding() + 120.dp&#10;                ),&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                item {&#10;                    ShoppingListHeader(&#10;                        searchQuery = searchQuery,&#10;                        onSearchQueryChange = { searchQuery = it },&#10;                        checkedItems = checkedItems.size,&#10;                        totalItems = allItems.size,&#10;                        progress = progress&#10;                    )&#10;                }&#10;&#10;                item {&#10;                    val weekDateRange = remember(weekOffset) { getWeekDateRange(weekOffset) }&#10;                    WeekNavigator(&#10;                        weekDateRange = weekDateRange,&#10;                        onPreviousWeek = { weekOffset-- },&#10;                        onNextWeek = { weekOffset++ },&#10;                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                    )&#10;                }&#10;&#10;                when {&#10;                    uiState.isLoading -&gt; item { Box(Modifier.fillParentMaxSize(), contentAlignment = Alignment.Center) { CircularProgressIndicator() } }&#10;                    uiState.error != null -&gt; item { Text(uiState.error!!, color = MaterialTheme.colorScheme.error, modifier = Modifier.padding(16.dp)) }&#10;                    filteredList.isEmpty() &amp;&amp; !uiState.isLoading -&gt; item { EmptyState(modifier = Modifier.padding(top = 60.dp)) }&#10;                    else -&gt; {&#10;                        filteredList.entries.forEach { (category, items) -&gt;&#10;                            stickyHeader {&#10;                                Text(&#10;                                    text = category,&#10;                                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.Bold),&#10;                                    color = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(horizontal = 16.dp, vertical = 8.dp)&#10;                                )&#10;                            }&#10;                            items(items, key = { it.id }) { item -&gt;&#10;                                ShoppingListItemRow(&#10;                                    item = item,&#10;                                    onCheck = { viewModel.toggleItemChecked(item.id) },&#10;                                    onEdit = { selectedItem -&gt;&#10;                                        Log.d(&quot;ShoppingListScreen&quot;, &quot; EDIT_ITEM_ROW: itemId=${selectedItem.id}, name='${selectedItem.name}'&quot;)&#10;                                        itemToEdit = selectedItem&#10;                                        showEditItemDialog = true&#10;                                    },&#10;                                    onDelete = { selectedItem -&gt;&#10;                                        Log.d(&quot;ShoppingListScreen&quot;, &quot; DELETE_ITEM_ROW: itemId=${selectedItem.id}, name='${selectedItem.name}'&quot;)&#10;                                        viewModel.deleteItem(selectedItem.id)&#10;                                    },&#10;                                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        val selectedIndex = 2&#10;        FloatingBottomNavBar(&#10;            items = navItems,&#10;            selectedIndex = selectedIndex,&#10;            onItemSelected = { index -&gt;&#10;                val destination = navItems[index].route&#10;                if (navController.currentDestination?.route != destination) {&#10;                    navController.navigate(destination) {&#10;                        popUpTo(navController.graph.findStartDestination().id) { saveState = true }&#10;                        launchSingleTop = true&#10;                        restoreState = true&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.align(Alignment.BottomCenter)&#10;        )&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomEnd)&#10;                .padding(end = 16.dp, bottom = 96.dp)&#10;        ) {&#10;            Column(&#10;                verticalArrangement = Arrangement.spacedBy(8.dp),&#10;                horizontalAlignment = Alignment.End&#10;            ) {&#10;                // Botón de eliminar todos los marcados (solo aparece si hay items seleccionados)&#10;                if (checkedItems.isNotEmpty()) {&#10;                    FloatingActionButton(&#10;                        onClick = { viewModel.clearCheckedItems() },&#10;                        containerColor = MaterialTheme.colorScheme.errorContainer,&#10;                        contentColor = MaterialTheme.colorScheme.onErrorContainer,&#10;                        modifier = Modifier.size(48.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.DeleteSweep,&#10;                            contentDescription = &quot;Eliminar todos los marcados&quot;&#10;                        )&#10;                    }&#10;                }&#10;&#10;&#10;                // Botón de agregar (SIEMPRE visible)&#10;                FloatingActionButton(&#10;                    onClick = { showAddItemDialog = true },&#10;                    containerColor = MaterialTheme.colorScheme.primary,&#10;                    contentColor = MaterialTheme.colorScheme.onPrimary&#10;                ) {&#10;                    Icon(imageVector = Icons.Default.Add, contentDescription = &quot;Añadir Ítem&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showAddItemDialog) {&#10;        AddItemDialog(&#10;            onDismiss = { showAddItemDialog = false },&#10;            onConfirm = { name, quantity -&gt;&#10;                viewModel.addItem(name, quantity)&#10;                showAddItemDialog = false&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showEditItemDialog &amp;&amp; itemToEdit != null) {&#10;        val item = itemToEdit!!&#10;        EditItemDialog(&#10;            item = item,&#10;            onDismiss = {&#10;                showEditItemDialog = false&#10;                itemToEdit = null&#10;            },&#10;            onConfirm = { name, quantity -&gt;&#10;                viewModel.editItem(item.id, name, quantity)&#10;                showEditItemDialog = false&#10;                itemToEdit = null&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Composable que muestra la cabecera de la lista de compras.&#10; * Incluye una barra de progreso que visualiza la proporción de elementos marcados,&#10; * así como un campo de búsqueda para filtrar elementos por nombre.&#10; * &#10; * @param searchQuery Texto actual en el campo de búsqueda&#10; * @param onSearchQueryChange Callback invocado cuando cambia el texto de búsqueda&#10; * @param checkedItems Número de elementos marcados como completados&#10; * @param totalItems Número total de elementos en la lista&#10; * @param progress Proporción de elementos completados (entre 0 y 1)&#10; */&#10;@Composable&#10;private fun ShoppingListHeader(&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    checkedItems: Int,&#10;    totalItems: Int,&#10;    progress: Float&#10;) {&#10;    val animatedProgress by animateFloatAsState(targetValue = progress, label = &quot;progressAnimation&quot;)&#10;&#10;    Column(&#10;        modifier = Modifier.padding(horizontal = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        if (totalItems &gt; 0) {&#10;            Column {&#10;                Text(&#10;                    text = &quot;Progreso: $checkedItems de $totalItems&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Spacer(Modifier.height(8.dp))&#10;                LinearProgressIndicator(&#10;                    progress = { animatedProgress },&#10;                    modifier = Modifier.fillMaxWidth().height(8.dp).clip(RoundedCornerShape(4.dp)),&#10;                    strokeCap = StrokeCap.Round&#10;                )&#10;            }&#10;        }&#10;&#10;        TextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            placeholder = { Text(&quot;Buscar ingrediente...&quot;) },&#10;            leadingIcon = { Icon(Icons.Default.Search, contentDescription = &quot;Buscar&quot;) },&#10;            singleLine = true,&#10;            shape = RoundedCornerShape(16.dp),&#10;            colors = TextFieldDefaults.colors(&#10;                focusedIndicatorColor = Color.Transparent,&#10;                unfocusedIndicatorColor = Color.Transparent,&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Composable que representa un elemento individual de la lista de compras.&#10; * Muestra el nombre del elemento, cantidad, checkbox para marcarlo como completado,&#10; * y botones para editar y eliminar. Aplica estilos visuales diferentes según&#10; * si el elemento está marcado como completado o no.&#10; * &#10; * @param item Modelo de datos del elemento de compra a mostrar&#10; * @param onCheck Callback invocado cuando se marca/desmarca el elemento&#10; * @param onEdit Callback invocado cuando se solicita editar el elemento&#10; * @param onDelete Callback invocado cuando se solicita eliminar el elemento&#10; * @param modifier Modificador opcional para personalizar el layout&#10; */&#10;@Composable&#10;private fun ShoppingListItemRow(&#10;    item: ShoppingItem,&#10;    onCheck: () -&gt; Unit,&#10;    onEdit: (ShoppingItem) -&gt; Unit = {},&#10;    onDelete: (ShoppingItem) -&gt; Unit = {},&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val textDecoration = if (item.isChecked) TextDecoration.LineThrough else TextDecoration.None&#10;    val textColor = if (item.isChecked) MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f) else MaterialTheme.colorScheme.onSurface&#10;&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = if (item.isChecked) 4.dp else 1.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Checkbox(&#10;                checked = item.isChecked,&#10;                onCheckedChange = { onCheck() }&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;&#10;            Column(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .clickable(onClick = onCheck)&#10;            ) {&#10;                Text(&#10;                    text = item.name,&#10;                    textDecoration = textDecoration,&#10;                    color = textColor,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;                if (item.quantity.isNotBlank()) {&#10;                    Text(&#10;                        text = item.quantity,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = textColor.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Botones de acción directos en cada fila&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                // Botón Editar&#10;                Surface(&#10;                    onClick = {&#10;                        Log.d(&quot;ShoppingListScreen&quot;, &quot; EDIT_ITEM_ROW: itemId=${item.id}, name='${item.name}'&quot;)&#10;                        onEdit(item)&#10;                    },&#10;                    modifier = Modifier.size(36.dp),&#10;                    shape = RoundedCornerShape(8.dp),&#10;                    color = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)&#10;                ) {&#10;                    Box(&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.EditNote,&#10;                            contentDescription = &quot;Editar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary,&#10;                            modifier = Modifier.size(20.dp)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Botón Eliminar&#10;                Surface(&#10;                    onClick = {&#10;                        Log.d(&quot;ShoppingListScreen&quot;, &quot; DELETE_ITEM_ROW: itemId=${item.id}, name='${item.name}'&quot;)&#10;                        onDelete(item)&#10;                    },&#10;                    modifier = Modifier.size(36.dp),&#10;                    shape = RoundedCornerShape(8.dp),&#10;                    color = MaterialTheme.colorScheme.errorContainer.copy(alpha = 0.3f)&#10;                ) {&#10;                    Box(&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.DeleteOutline,&#10;                            contentDescription = &quot;Eliminar&quot;,&#10;                            tint = MaterialTheme.colorScheme.error,&#10;                            modifier = Modifier.size(20.dp)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Composable que muestra un diálogo para añadir un nuevo elemento a la lista de compras.&#10; * Contiene campos para el nombre y la cantidad, con validación básica de que el nombre&#10; * no puede estar vacío.&#10; * &#10; * @param onDismiss Callback invocado cuando se cierra el diálogo sin confirmar&#10; * @param onConfirm Callback invocado con el nombre y cantidad cuando se confirma la adición&#10; */&#10;@Composable&#10;private fun AddItemDialog(onDismiss: () -&gt; Unit, onConfirm: (name: String, quantity: String) -&gt; Unit) {&#10;    var name by remember { mutableStateOf(&quot;&quot;) }&#10;    var quantity by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Añadir Ítem Manualmente&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(value = name, onValueChange = { name = it }, label = { Text(&quot;Nombre del ítem&quot;) })&#10;                OutlinedTextField(value = quantity, onValueChange = { quantity = it }, label = { Text(&quot;Cantidad (ej: 2 tazas)&quot;) })&#10;            }&#10;        },&#10;        confirmButton = { Button(onClick = { onConfirm(name, quantity) }, enabled = name.isNotBlank()) { Text(&quot;Añadir&quot;) } },&#10;        dismissButton = { TextButton(onClick = onDismiss) { Text(&quot;Cancelar&quot;) } }&#10;    )&#10;}&#10;&#10;/**&#10; * Composable que muestra un diálogo para editar un elemento existente de la lista de compras.&#10; * Muestra los valores actuales del elemento y permite modificarlos, con validación&#10; * básica de que el nombre no puede estar vacío.&#10; * &#10; * @param item Elemento de la lista de compras a editar&#10; * @param onDismiss Callback invocado cuando se cierra el diálogo sin confirmar&#10; * @param onConfirm Callback invocado con el nuevo nombre y cantidad cuando se confirma la edición&#10; */&#10;@Composable&#10;private fun EditItemDialog(item: ShoppingItem, onDismiss: () -&gt; Unit, onConfirm: (name: String, quantity: String) -&gt; Unit) {&#10;    var name by remember { mutableStateOf(item.name) }&#10;    var quantity by remember { mutableStateOf(item.quantity) }&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(&quot;Editar Ítem&quot;) },&#10;        text = {&#10;            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {&#10;                OutlinedTextField(value = name, onValueChange = { name = it }, label = { Text(&quot;Nombre del ítem&quot;) })&#10;                OutlinedTextField(value = quantity, onValueChange = { quantity = it }, label = { Text(&quot;Cantidad (ej: 2 tazas)&quot;) })&#10;            }&#10;        },&#10;        confirmButton = { Button(onClick = { onConfirm(name, quantity) }, enabled = name.isNotBlank()) { Text(&quot;Guardar&quot;) } },&#10;        dismissButton = { TextButton(onClick = onDismiss) { Text(&quot;Cancelar&quot;) } }&#10;    )&#10;}&#10;&#10;/**&#10; * Composable que muestra un estado visual cuando la lista de compras está vacía.&#10; * Incluye un icono, mensaje principal y texto explicativo con sugerencias para el usuario.&#10; * &#10; * @param modifier Modificador opcional para personalizar el layout&#10; */&#10;@Composable&#10;private fun EmptyState(modifier: Modifier = Modifier) {&#10;    Column(&#10;        modifier = modifier.fillMaxSize().padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Icon(&#10;            imageVector = Icons.Filled.ShoppingCart,&#10;            contentDescription = null,&#10;            modifier = Modifier.size(80.dp),&#10;            tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.4f)&#10;        )&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;        Text(&quot;Tu lista está vacía&quot;, style = MaterialTheme.typography.headlineSmall)&#10;        Text(&quot;Genera una lista desde tu plan o añade ítems manualmente.&quot;, textAlign = androidx.compose.ui.text.style.TextAlign.Center)&#10;    }&#10;}&#10;&#10;/**&#10; * Función de utilidad que calcula el rango de fechas de la semana a mostrar,&#10; * basado en el desplazamiento desde la semana actual.&#10; * &#10; * @param weekOffset Número de semanas de desplazamiento desde la semana actual&#10; * @return Cadena de texto formateada con el rango de fechas (ej. &quot;1 Ago - 7 Ago&quot;)&#10; */&#10;private fun getWeekDateRange(weekOffset: Int): String {&#10;    val weekFormat = SimpleDateFormat(&quot;d MMM&quot;, Locale(&quot;es&quot;, &quot;ES&quot;))&#10;    val calendar = Calendar.getInstance().apply {&#10;        add(Calendar.WEEK_OF_YEAR, weekOffset)&#10;        set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)&#10;    }&#10;    val startOfWeek = calendar.time&#10;    calendar.add(Calendar.DAY_OF_YEAR, 6)&#10;    val endOfWeek = calendar.time&#10;    return &quot;${weekFormat.format(startOfWeek)} - ${weekFormat.format(endOfWeek)}&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/ui/theme/Color.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/ui/theme/Color.kt" />
              <option name="originalContent" value="val Background = Color(0xFFFFFFFF)    // Blanco&#10;val Surface = Color(0xFFF8F9FA)       // Tarjetas claras&#10;val FieldBg = Color(0xFFF3F6FA)       // Inputs &amp; fields claros&#10;val Text = Color(0xFF18191A)          // Texto principal&#10;// ---------- LIGHT THEME ----------&#10;val Primary = Color(0xFF43A047)       // Verde principal&#10;val PrimaryDark = Color(0xFF00701A)   // Verde oscuro&#10;val Accent = Color(0xFFFFC107)        // Amarillo/Accent&#10;val Background = Color(0xFFFFFFFF)    // Blanco&#10;val Surface = Color(0xFFF8F9FA)       // Tarjetas claras&#10;val FieldBg = Color(0xFFF3F6FA)       // Inputs &amp; fields claros&#10;val Text = Color(0xFF18191A)          // Texto principal&#10;val TextSecondary = Color(0xFF50505A) // Texto secundario&#10;val BorderLight = Color(0xFFE0E0E0)   // Bordes &amp; outlines claros&#10;val ErrorRed = Color(0xFFDB2C2C)      // Errores&#10;" />
              <option name="updatedContent" value="/**&#10; * Color.kt&#10; * &#10; * Propósito: Define la paleta de colores utilizada en toda la aplicación AnyMeal.&#10; * Contiene definiciones para los colores de los temas claro y oscuro, incluyendo&#10; * colores primarios, de fondo, superficie, texto y otros elementos de la interfaz.&#10; * Estos colores son utilizados por el sistema de temas de Jetpack Compose.&#10; */&#10;package com.noskill.anymeal.ui.theme&#10;&#10;import androidx.compose.ui.graphics.Color&#10;&#10;/**&#10; * ---------- COLORES DEL TEMA CLARO ----------&#10; * Definición de colores para el modo de tema claro de la aplicación.&#10; */&#10;&#10;/** Color primario verde - usado para elementos principales de la UI, botones y barras */&#10;val Primary = Color(0xFF43A047)&#10;&#10;/** Variante oscura del color primario - usada para estados pressed y destacados */&#10;val PrimaryDark = Color(0xFF00701A)&#10;&#10;/** Color de acento amarillo - usado para elementos de atención y destacados */&#10;val Accent = Color(0xFFFFC107)&#10;&#10;/** Color de fondo principal - blanco puro para la base de la UI */&#10;val Background = Color(0xFFFFFFFF)&#10;&#10;/** Color de superficie - usado en tarjetas y elementos elevados */&#10;val Surface = Color(0xFFF8F9FA)&#10;&#10;/** Color de fondo para campos de entrada y áreas interactivas */&#10;val FieldBg = Color(0xFFF3F6FA)&#10;&#10;/** Color primario para textos - casi negro para máxima legibilidad */&#10;val Text = Color(0xFF18191A)&#10;&#10;/** Color secundario para textos - gris oscuro para información menos importante */&#10;val TextSecondary = Color(0xFF50505A)&#10;&#10;/** Color para bordes y contornos en tema claro */&#10;val BorderLight = Color(0xFFE0E0E0)&#10;&#10;/** Color rojo para indicar errores y alertas */&#10;val ErrorRed = Color(0xFFDB2C2C)&#10;&#10;/**&#10; * ---------- COLORES DEL TEMA OSCURO ----------&#10; * Definición de colores para el modo de tema oscuro de la aplicación.&#10; */&#10;&#10;/** Color de fondo principal para tema oscuro - negro con tinte gris */&#10;val BackgroundDark = Color(0xFF111113)&#10;&#10;/** Color de superficie para tema oscuro - usado en tarjetas y elementos elevados */&#10;val SurfaceDark = Color(0xFF232429)&#10;&#10;/** Color de fondo para campos de entrada en tema oscuro */&#10;val FieldBgDark = Color(0xFF202124)&#10;&#10;/** Color primario para textos en tema oscuro - casi blanco para máxima legibilidad */&#10;val TextDark = Color(0xFFF8F8FF)&#10;&#10;/** Color secundario para textos en tema oscuro - gris claro para información menos importante */&#10;val TextSecondaryDark = Color(0xFFA8ADB7)&#10;&#10;/** Color para bordes y contornos en tema oscuro */&#10;val BorderDark = Color(0xFF393A41)&#10;&#10;/** Variante del color de acento adaptada para el tema oscuro - amarillo suave */&#10;val AccentDark = Color(0xFFFFE066)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/ui/theme/Shapes.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/ui/theme/Shapes.kt" />
              <option name="originalContent" value="/* --------------------------------------------------------------------&#10; * Archivo: Shape.kt&#10; * Descripción: Define las formas (shapes) globales para la aplicación,&#10; * asegurando una consistencia visual en la curvatura de las esquinas&#10; * de todos los componentes.&#10; * --------------------------------------------------------------------&#10; */&#10;package com.noskill.anymeal.ui.theme&#10;&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Shapes&#10;import androidx.compose.ui.unit.dp&#10;&#10;// El objeto 'AppShapes' centraliza la definición de las formas que se&#10;// usarán en toda la aplicación a través de MaterialTheme.&#10;// Esto permite que componentes como Card, Button, etc., tengan un&#10;// radio de borde consistente y predecible.&#10;&#10;" />
              <option name="updatedContent" value="/**&#10; * Shapes.kt&#10; * &#10; * Propósito: Define las formas (shapes) utilizadas en toda la aplicación AnyMeal para &#10; * asegurar consistencia visual en la curvatura de las esquinas de los diferentes componentes&#10; * de la interfaz. Estos valores son utilizados por el sistema de temas de Jetpack Compose.&#10; */&#10;package com.noskill.anymeal.ui.theme&#10;&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Shapes&#10;import androidx.compose.ui.unit.dp&#10;&#10;/**&#10; * Definición de las formas (shapes) que se utilizarán en toda la aplicación.&#10; * Proporciona una colección de formas con diferentes radios de borde para mantener&#10; * la consistencia visual en los componentes de la interfaz.&#10; * &#10; * Estas formas se utilizan a través de MaterialTheme en toda la aplicación, permitiendo&#10; * que componentes como Card, Button, TextField, etc. tengan radios de borde consistentes.&#10; */&#10;val AppShapes = Shapes(&#10;    /**&#10;     * Esquinas con radio pequeño (12dp)&#10;     * Usadas para elementos compactos como botones, chips (píldoras) o campos de texto.&#10;     */&#10;    small = RoundedCornerShape(12.dp),&#10;&#10;    /**&#10;     * Esquinas con radio mediano (20dp)&#10;     * Estándar para la mayoría de componentes como tarjetas de recetas (Cards) o diálogos.&#10;     * Este tamaño es el más utilizado en la aplicación.&#10;     */&#10;    medium = RoundedCornerShape(20.dp),&#10;&#10;    /**&#10;     * Esquinas con radio grande (32dp)&#10;     * Utilizadas para componentes de gran tamaño que requieren mayor impacto visual,&#10;     * como bottom sheets o tarjetas destacadas.&#10;     */&#10;    large = RoundedCornerShape(32.dp)&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/util/Result.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/util/Result.kt" />
              <option name="originalContent" value="// ========================================================================&#10;// Archivo: util/Result.kt&#10;// ========================================================================&#10;" />
              <option name="updatedContent" value="/**&#10; * Result.kt&#10; * &#10; * Propósito: Define una clase sellada genérica que representa los diferentes estados &#10; * de una operación asíncrona, especialmente para peticiones de red. Permite manejar &#10; * de forma segura y tipada los casos de éxito, error y carga.&#10; */&#10;package com.noskill.anymeal.util&#10;&#10;/**&#10; * Clase sellada genérica que representa los posibles resultados de una operación.&#10; * Implementa el patrón Result para manejar estados de operaciones asíncronas.&#10; * &#10; * @param T Tipo de datos que se espera en caso de éxito&#10; */&#10;sealed class Result&lt;out T&gt; {&#10;    /**&#10;     * Representa una operación exitosa con datos disponibles.&#10;     * &#10;     * @param data Los datos obtenidos tras la operación exitosa&#10;     */&#10;    data class Success&lt;out T&gt;(val data: T) : Result&lt;T&gt;()&#10;    &#10;    /**&#10;     * Representa un error en la operación.&#10;     * &#10;     * @param message Mensaje descriptivo del error ocurrido&#10;     */&#10;    data class Error(val message: String) : Result&lt;Nothing&gt;()&#10;    &#10;    /**&#10;     * Representa que una operación está en proceso y aún no ha finalizado.&#10;     * Object singleton ya que no requiere datos adicionales.&#10;     */&#10;    object Loading : Result&lt;Nothing&gt;()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/util/ValidationUtils.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/util/ValidationUtils.kt" />
              <option name="originalContent" value="// ========================================================================&#10;// Archivo: util/ValidationUtils.kt&#10;// ========================================================================&#10;" />
              <option name="updatedContent" value="/**&#10; * ValidationUtils.kt&#10; * &#10; * Propósito: Proporciona funciones de utilidad para validar diferentes tipos de datos&#10; * ingresados por el usuario, como direcciones de correo electrónico, contraseñas, etc.&#10; * Estas funciones son utilizadas en toda la aplicación para garantizar la integridad&#10; * de los datos antes de procesarlos.&#10; */&#10;package com.noskill.anymeal.util&#10;&#10;import android.util.Patterns&#10;&#10;/**&#10; * Valida si una cadena de texto corresponde a un formato válido de dirección de correo electrónico.&#10; * Utiliza el patrón predefinido de Android para validación de emails.&#10; *&#10; * @param email La cadena de texto a validar como dirección de correo electrónico&#10; * @return true si el formato del email es válido, false en caso contrario&#10; */&#10;fun isValidEmail(email: String): Boolean {&#10;    return Patterns.EMAIL_ADDRESS.matcher(email).matches()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/viewmodel/AchievementsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/viewmodel/AchievementsViewModel.kt" />
              <option name="originalContent" value="// ========================================================================&#10;// Archivo MODIFICADO: viewmodel/AchievementsViewModel.kt&#10;// Propósito: Corregido para manejar el estado 'Result' del PlannerViewModel.&#10;// ========================================================================&#10;import kotlinx.coroutines.flow.stateIn&#10;&#10;class AchievementsViewModel(&#10;    plannerViewModel: PlannerViewModel,&#10;    favoritesViewModel: FavoritesViewModel&#10;) : ViewModel() {&#10;        // --- CORRECCIÓN ---&#10;        // Se extraen los datos del plan solo si la carga fue exitosa.&#10;        // Si está cargando o hay un error, se usan valores por defecto (0).&#10;        val (totalPlannedDays, totalRecipesAdded) = when (planResult) {&#10;        // --- CORRECCIÓN ---&#10;        // Se extraen los datos del plan solo si la carga fue exitosa.&#10;&#10;        listOf(&#10;        // --- CORRECCIÓN ---&#10;        // Se extraen los datos del plan solo si la carga fue exitosa.&#10;            Achievement(&#10;                description = &quot;Añade 10 recetas a tus planes.&quot;,&#10;                icon = Icons.Outlined.Restaurant,&#10;                icon = Icons.Outlined.FavoriteBorder,&#10;                isUnlocked = totalFavorites &gt;= 5&#10;            else -&gt; Pair(0, 0) // Valores por defecto&#10;    ) { planResult, favoriteIds -&gt; // El nombre de la variable se cambia a planResult para mayor claridad&#10;                title = &quot;Amante de la Cocina&quot;,&#10;        // --- CORRECCIÓN ---&#10;        // Se extraen los datos del plan solo si la carga fue exitosa.&#10;                icon = Icons.Outlined.Favorite,&#10;            ),&#10;            Achievement(&#10;                title = &quot;Maestro Culinario&quot;,&#10;                description = &quot;Añade 50 recetas a tus planes.&quot;,&#10;                icon = Icons.Outlined.EmojiEvents,&#10;                isUnlocked = totalRecipesAdded &gt;= 50&#10;            )&#10;        )&#10;    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())&#10;            else -&gt; Pair(0, 0) // Valores por defecto&#10;&#10;// Factory para poder pasarle parámetros al AchievementsViewModel&#10;class AchievementsViewModelFactory(&#10;    private val plannerViewModel: PlannerViewModel,&#10;) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(AchievementsViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return AchievementsViewModel(plannerViewModel, favoritesViewModel) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="/**&#10; * AchievementsViewModel.kt&#10; * &#10; * Propósito: Gestiona la lógica de los logros de usuario dentro de la aplicación, realizando un seguimiento&#10; * de diversas actividades como la planificación de comidas y el marcado de recetas como favoritas.&#10; * Este ViewModel combina datos de PlannerViewModel y FavoritesViewModel para determinar qué logros&#10; * ha desbloqueado el usuario.&#10; */&#10;package com.noskill.anymeal.viewmodel&#10;&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.outlined.*&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.viewModelScope&#10;import com.noskill.anymeal.ui.models.Achievement&#10;import com.noskill.anymeal.util.Result&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;&#10;/**&#10; * ViewModel que gestiona la lógica de logros dentro de la aplicación.&#10; * &#10; * @param plannerViewModel ViewModel que contiene información sobre los planes de comidas del usuario.&#10; * @param favoritesViewModel ViewModel que contiene las recetas favoritas del usuario.&#10; */&#10;class AchievementsViewModel(&#10;    plannerViewModel: PlannerViewModel,&#10;    favoritesViewModel: FavoritesViewModel&#10;) : ViewModel() {&#10;&#10;    /**&#10;     * StateFlow que emite la lista de logros y su estado (desbloqueado o no).&#10;     * Combina datos de los planes de comidas y recetas favoritas para determinar&#10;     * el estado de cada logro.&#10;     */&#10;    val achievements: StateFlow&lt;List&lt;Achievement&gt;&gt; = combine(&#10;        plannerViewModel.planState,&#10;        favoritesViewModel.favoriteRecipeIds&#10;    ) { planResult, favoriteIds -&gt; &#10;&#10;        // Extrae datos del plan solo si la carga fue exitosa.&#10;        // Si está cargando o hay un error, se usan valores por defecto (0).&#10;        val (totalPlannedDays, totalRecipesAdded) = when (planResult) {&#10;            is Result.Success -&gt; {&#10;                val planData = planResult.data&#10;                val days = planData.size&#10;                val recipes = planData.values.sumOf { dailyPlan -&gt;&#10;                    dailyPlan.meals.values.sumOf { it.size }&#10;                }&#10;                Pair(days, recipes)&#10;            }&#10;            else -&gt; Pair(0, 0) // Valores por defecto para estados de carga o error&#10;        }&#10;&#10;        val totalFavorites = favoriteIds.size&#10;&#10;        // Lista de logros disponibles en la aplicación con su estado de desbloqueo&#10;        listOf(&#10;            Achievement(&#10;                title = &quot;Primer Plan&quot;,&#10;                description = &quot;Crea tu primer plan de comidas para un día.&quot;,&#10;                icon = Icons.Outlined.Flag,&#10;                isUnlocked = totalPlannedDays &gt;= 1&#10;            ),&#10;            Achievement(&#10;                title = &quot;Planificador Semanal&quot;,&#10;                description = &quot;Planifica comidas para 7 días diferentes.&quot;,&#10;                icon = Icons.Outlined.DateRange,&#10;                isUnlocked = totalPlannedDays &gt;= 7&#10;            ),&#10;            Achievement(&#10;                title = &quot;Chef Organizado&quot;,&#10;                description = &quot;Añade 10 recetas a tus planes.&quot;,&#10;                icon = Icons.Outlined.Restaurant,&#10;                isUnlocked = totalRecipesAdded &gt;= 10&#10;            ),&#10;            Achievement(&#10;                title = &quot;Coleccionista de Sabores&quot;,&#10;                description = &quot;Guarda 5 recetas en tus favoritos.&quot;,&#10;                icon = Icons.Outlined.FavoriteBorder,&#10;                isUnlocked = totalFavorites &gt;= 5&#10;            ),&#10;            Achievement(&#10;                title = &quot;Amante de la Cocina&quot;,&#10;                description = &quot;Guarda 15 recetas en tus favoritos.&quot;,&#10;                icon = Icons.Outlined.Favorite,&#10;                isUnlocked = totalFavorites &gt;= 15&#10;            ),&#10;            Achievement(&#10;                title = &quot;Maestro Culinario&quot;,&#10;                description = &quot;Añade 50 recetas a tus planes.&quot;,&#10;                icon = Icons.Outlined.EmojiEvents,&#10;                isUnlocked = totalRecipesAdded &gt;= 50&#10;            )&#10;        )&#10;    }.stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())&#10;}&#10;&#10;/**&#10; * Factory para la creación de instancias de AchievementsViewModel.&#10; * Permite inyectar las dependencias necesarias (otros ViewModels) al crear el ViewModel.&#10; * &#10; * @param plannerViewModel ViewModel con la información de planes de comidas.&#10; * @param favoritesViewModel ViewModel con la información de recetas favoritas.&#10; */&#10;class AchievementsViewModelFactory(&#10;    private val plannerViewModel: PlannerViewModel,&#10;    private val favoritesViewModel: FavoritesViewModel&#10;) : ViewModelProvider.Factory {&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;        if (modelClass.isAssignableFrom(AchievementsViewModel::class.java)) {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            return AchievementsViewModel(plannerViewModel, favoritesViewModel) as T&#10;        }&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/viewmodel/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/viewmodel/AuthViewModel.kt" />
              <option name="originalContent" value="// ========================================================================&#10;// Archivo: viewmodel/AuthViewModel.kt&#10;// ========================================================================&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class AuthViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val apiService = NetworkModule.provideApiService(application)&#10;    private val authRepository = AuthRepository(apiService)&#10;        viewModelScope.launch {&#10;            _authState.value = Result.Loading&#10;                    val token = response.body()!!.token&#10;                }&#10;" />
              <option name="updatedContent" value="/**&#10; * AuthViewModel.kt&#10; * &#10; * Propósito: Gestiona la autenticación de usuarios en la aplicación, incluyendo procesos de &#10; * inicio de sesión, registro y mantenimiento del estado de autenticación. Actúa como intermediario&#10; * entre la interfaz de usuario y el repositorio de autenticación.&#10; */&#10;package com.noskill.anymeal.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.noskill.anymeal.data.local.SessionManager&#10;import com.noskill.anymeal.data.repository.AuthRepository&#10;import com.noskill.anymeal.data.di.NetworkModule&#10;import com.noskill.anymeal.dto.AuthResponse&#10;import com.noskill.anymeal.dto.LoginRequest&#10;import com.noskill.anymeal.dto.RegisterRequest&#10;import com.noskill.anymeal.util.Result&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * ViewModel que maneja toda la lógica relacionada con la autenticación de usuarios.&#10; * Extiende AndroidViewModel para tener acceso al contexto de la aplicación.&#10; * &#10; * @param application Instancia de la aplicación para acceder al contexto&#10; */&#10;class AuthViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    /**&#10;     * Servicio de API para comunicación con el backend de autenticación&#10;     */&#10;    private val apiService = NetworkModule.provideApiService(application)&#10;    &#10;    /**&#10;     * Repositorio que encapsula la lógica de operaciones de autenticación&#10;     */&#10;    private val authRepository = AuthRepository(apiService)&#10;    &#10;    /**&#10;     * Gestor de sesión para almacenar tokens de autenticación localmente&#10;     */&#10;    private val sessionManager = SessionManager(application)&#10;&#10;    /**&#10;     * Estado interno mutable que representa el resultado de las operaciones de autenticación&#10;     */&#10;    private val _authState = MutableStateFlow&lt;Result&lt;AuthResponse&gt;&gt;(Result.Success(AuthResponse(&quot;&quot;)))&#10;    &#10;    /**&#10;     * Estado público de autenticación observable desde la UI.&#10;     * Contiene el resultado de las operaciones de autenticación (éxito, error o carga).&#10;     */&#10;    val authState: StateFlow&lt;Result&lt;AuthResponse&gt;&gt; = _authState&#10;&#10;    /**&#10;     * Realiza el proceso de inicio de sesión con las credenciales proporcionadas.&#10;     * Actualiza el estado de autenticación y guarda el token en sesión si es exitoso.&#10;     * &#10;     * @param request Objeto con las credenciales de inicio de sesión (usuario/email y contraseña)&#10;     */&#10;    fun login(request: LoginRequest) {&#10;        viewModelScope.launch {&#10;            _authState.value = Result.Loading // Indica que el proceso de login está en curso&#10;            try {&#10;                val response = authRepository.login(request)&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val token = response.body()!!.token // Obtiene el token de autenticación&#10;                    sessionManager.saveAuthToken(token) // Almacena el token para futuras solicitudes&#10;                    _authState.value = Result.Success(response.body()!!) // Notifica éxito a la UI&#10;                } else {&#10;                    _authState.value = Result.Error(&quot;Usuario o contraseña incorrectos.&quot;) // Notifica error de credenciales&#10;                }&#10;            } catch (e: Exception) {&#10;                _authState.value = Result.Error(&quot;Error de conexión: ${e.message}&quot;) // Notifica error de red&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Realiza el proceso de registro de un nuevo usuario con la información proporcionada.&#10;     * Actualiza el estado de autenticación y guarda el token en sesión si es exitoso.&#10;     * &#10;     * @param request Objeto con los datos de registro (nombre, email, contraseña, etc.)&#10;     */&#10;    fun register(request: RegisterRequest) {&#10;        viewModelScope.launch {&#10;            _authState.value = Result.Loading // Indica que el proceso de registro está en curso&#10;            try {&#10;                val response = authRepository.register(request)&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val token = response.body()!!.token // Obtiene el token de autenticación&#10;                    sessionManager.saveAuthToken(token) // Almacena el token para futuras solicitudes&#10;                    _authState.value = Result.Success(response.body()!!) // Notifica éxito a la UI&#10;                } else {&#10;                    _authState.value = Result.Error(&quot;No se pudo registrar. El usuario o email ya podría existir.&quot;) // Notifica error de registro&#10;                }&#10;            } catch (e: Exception) {&#10;                _authState.value = Result.Error(&quot;Error de conexión: ${e.message}&quot;) // Notifica error de red&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/viewmodel/FavoritesViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/viewmodel/FavoritesViewModel.kt" />
              <option name="originalContent" value="// ========================================================================&#10;// Archivo MODIFICADO: viewmodel/FavoritesViewModel.kt&#10;// Propósito: Se elimina la dependencia del archivo Mappers.kt y se integra&#10;// la lógica de conversión directamente aquí.&#10;// ========================================================================&#10;import com.noskill.anymeal.data.di.NetworkModule&#10;import com.noskill.anymeal.dto.RecipePreviewResponse&#10;import com.noskill.anymeal.ui.models.RecipePreviewUi&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;data class FavoritesUiState(&#10;    val isLoading: Boolean = true,&#10;    private val repository = FavoritesRepository(apiService)&#10;&#10;                    _uiState.update { it.copy(isLoading = false, errorMessage = &quot;Error al cargar favoritos&quot;) }&#10;                }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * FavoritesViewModel.kt&#10; * &#10; * Propósito: Gestiona las recetas favoritas del usuario, proporcionando funcionalidades para&#10; * cargar, añadir y eliminar recetas de la lista de favoritos. Maneja el estado de la UI&#10; * relacionado con las recetas favoritas y expone flujos reactivos de datos para la interfaz.&#10; */&#10;package com.noskill.anymeal.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.noskill.anymeal.data.repository.FavoritesRepository&#10;import com.noskill.anymeal.data.di.NetworkModule&#10;import com.noskill.anymeal.dto.RecipePreviewResponse&#10;import com.noskill.anymeal.ui.models.RecipePreviewUi&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Clase de datos que representa el estado de la UI para la pantalla de favoritos.&#10; * &#10; * @property isLoading Indica si se está cargando información desde el repositorio&#10; * @property favoriteRecipes Lista de recetas marcadas como favoritas por el usuario&#10; * @property errorMessage Mensaje de error si ocurre algún problema, null si no hay errores&#10; */&#10;data class FavoritesUiState(&#10;    val isLoading: Boolean = true,&#10;    val favoriteRecipes: List&lt;RecipePreviewUi&gt; = emptyList(),&#10;    val errorMessage: String? = null&#10;)&#10;&#10;/**&#10; * ViewModel que gestiona la lógica de las recetas favoritas del usuario.&#10; * Proporciona métodos para cargar, añadir y eliminar recetas de favoritos.&#10; * &#10; * @param application Instancia de la aplicación para acceder al contexto&#10; */&#10;class FavoritesViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    /**&#10;     * Servicio de API para comunicación con el backend&#10;     */&#10;    private val apiService = NetworkModule.provideApiService(application)&#10;    &#10;    /**&#10;     * Repositorio que encapsula las operaciones relacionadas con favoritos&#10;     */&#10;    private val repository = FavoritesRepository(apiService)&#10;&#10;    /**&#10;     * Estado interno mutable de la UI para favoritos&#10;     */&#10;    private val _uiState = MutableStateFlow(FavoritesUiState())&#10;    &#10;    /**&#10;     * Estado público observable de la UI para la pantalla de favoritos&#10;     */&#10;    val uiState: StateFlow&lt;FavoritesUiState&gt; = _uiState.asStateFlow()&#10;&#10;    /**&#10;     * Conjunto de IDs de recetas favoritas derivado del estado de la UI.&#10;     * Útil para comprobar rápidamente si una receta está marcada como favorita.&#10;     */&#10;    val favoriteRecipeIds: StateFlow&lt;Set&lt;Int&gt;&gt; = uiState.map { it.favoriteRecipes.map { recipe -&gt; recipe.id }.toSet() }&#10;        .stateIn(viewModelScope, kotlinx.coroutines.flow.SharingStarted.Eagerly, emptySet())&#10;&#10;    /**&#10;     * Inicialización del ViewModel: carga la lista de favoritos al crear la instancia&#10;     */&#10;    init {&#10;        loadFavorites()&#10;    }&#10;&#10;    /**&#10;     * Carga la lista de recetas favoritas desde el repositorio.&#10;     * Actualiza el estado de la UI con los resultados o errores.&#10;     */&#10;    fun loadFavorites() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true, errorMessage = null) }&#10;            try {&#10;                val response = repository.getFavorites()&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    // La conversión se hace aquí directamente&#10;                    val favoriteList = response.body()!!.map { it.toUiModel() }&#10;                    _uiState.update { it.copy(isLoading = false, favoriteRecipes = favoriteList) }&#10;                } else {&#10;                    _uiState.update { it.copy(isLoading = false, errorMessage = &quot;Error al cargar favoritos&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, errorMessage = &quot;Error de conexión: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Alterna el estado de favorito de una receta. Si la receta ya está en favoritos,&#10;     * la elimina; si no está, la añade a la lista de favoritos.&#10;     * &#10;     * @param recipeId Identificador de la receta a alternar su estado de favorito&#10;     */&#10;    fun toggleFavorite(recipeId: Int) {&#10;        viewModelScope.launch {&#10;            val isCurrentlyFavorite = favoriteRecipeIds.value.contains(recipeId)&#10;            try {&#10;                val response = if (isCurrentlyFavorite) {&#10;                    repository.removeFavorite(recipeId.toLong())&#10;                } else {&#10;                    repository.addFavorite(recipeId.toLong())&#10;                }&#10;&#10;                if (response.isSuccessful) {&#10;                    loadFavorites()&#10;                } else {&#10;                    _uiState.update { it.copy(errorMessage = &quot;No se pudo actualizar el favorito&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(errorMessage = &quot;Error de conexión al actualizar favorito: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Función de extensión que convierte un objeto RecipePreviewResponse (DTO)&#10;     * a un objeto RecipePreviewUi para mostrar en la interfaz de usuario.&#10;     * &#10;     * @return Objeto RecipePreviewUi con los datos transformados para la UI&#10;     */&#10;    private fun RecipePreviewResponse.toUiModel(): RecipePreviewUi {&#10;        return RecipePreviewUi(&#10;            id = this.id.toInt(),&#10;            title = this.title,&#10;            imageUrl = this.imageUrl,&#10;            time = this.readyInMinutes,&#10;            difficulty = this.difficulty,&#10;            category = this.category&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/viewmodel/ProfileViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/noskill/anymeal/viewmodel/ProfileViewModel.kt" />
              <option name="originalContent" value="// ========================================================================&#10;// Archivo: ProfileViewModel.kt&#10;// Propósito: Gestiona el estado y la lógica relacionada con el perfil de usuario.&#10;//            Permite obtener, actualizar el perfil y cambiar la contraseña,&#10;//            manejando los estados de carga, éxito, error y reautenticación.&#10;// ========================================================================&#10;&#10;package com.noskill.anymeal.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.noskill.anymeal.data.local.SessionManager // Importar SessionManager&#10;import com.noskill.anymeal.data.model.User&#10;import com.noskill.anymeal.data.repository.UserRepository&#10;import com.noskill.anymeal.data.di.NetworkModule&#10;import com.noskill.anymeal.dto.ChangePasswordRequest&#10;import com.noskill.anymeal.dto.UpdateProfileRequest&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;// Define los posibles estados de una operación de guardado (Inactivo, Cargando, Éxito, Error)&#10;enum class SaveState { IDLE, LOADING, SUCCESS, ERROR }&#10;&#10;// El estado de la UI ahora incluye los datos del usuario y los estados de guardado.&#10;data class ProfileUiState(&#10;    val isLoading: Boolean = true,&#10;    val user: User? = null,&#10;    val profileSaveState: SaveState = SaveState.IDLE,&#10;    val passwordSaveState: SaveState = SaveState.IDLE,&#10;    val errorMessage: String? = null,&#10;    val requiresReauthentication: Boolean = false // &lt;-- NUEVO: Bandera para reautenticación&#10;)&#10;&#10;// ProfileViewModel extiende AndroidViewModel y gestiona el estado del perfil de usuario.&#10;class ProfileViewModel(application: Application) : AndroidViewModel(application) {&#10;    // Instancia del servicio de red y repositorio de usuario.&#10;    private val apiService = NetworkModule.provideApiService(application)&#10;    private val userRepository = UserRepository(apiService)&#10;    private val sessionManager = SessionManager(application) // Instancia de SessionManager para manejar el token&#10;&#10;    // StateFlow privado para almacenar el estado de la UI del perfil.&#10;    private val _uiState = MutableStateFlow(ProfileUiState())&#10;    // StateFlow público para observar el estado de la UI desde la interfaz.&#10;    val uiState: StateFlow&lt;ProfileUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Al inicializar el ViewModel, se obtiene el perfil del usuario automáticamente.&#10;    init {&#10;        fetchUserProfile()&#10;    }&#10;&#10;    // Método para obtener el perfil del usuario desde el repositorio.&#10;    // Actualiza el estado según el resultado de la llamada a la API.&#10;    fun fetchUserProfile() {&#10;        _uiState.update { it.copy(isLoading = true, errorMessage = null) }&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userRepository.getUserProfile()&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    _uiState.update { it.copy(isLoading = false, user = response.body()) }&#10;                } else if (response.code() == 401) {&#10;                    // Si el token expiró, se requiere reautenticación&#10;                    _uiState.update { it.copy(isLoading = false, requiresReauthentication = true, errorMessage = &quot;Sesión expirada. Inicia sesión nuevamente.&quot;) }&#10;                } else {&#10;                    _uiState.update { it.copy(isLoading = false, errorMessage = &quot;No se pudo obtener el perfil del usuario.&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, errorMessage = &quot;Error de conexión: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Método para actualizar el perfil del usuario.&#10;    // Actualiza el estado de guardado y maneja errores y éxito.&#10;    fun updateProfile(username: String, email: String) {&#10;        _uiState.update { it.copy(profileSaveState = SaveState.LOADING, errorMessage = null) }&#10;        viewModelScope.launch {&#10;            try {&#10;                val request = UpdateProfileRequest(username, email)&#10;                val response = userRepository.updateProfile(request)&#10;                if (response.isSuccessful) {&#10;                    _uiState.update { it.copy(profileSaveState = SaveState.SUCCESS) }&#10;                    fetchUserProfile() // Actualiza el perfil en la UI&#10;                } else if (response.code() == 401) {&#10;                    _uiState.update { it.copy(profileSaveState = SaveState.ERROR, requiresReauthentication = true, errorMessage = &quot;Sesión expirada. Inicia sesión nuevamente.&quot;) }&#10;                } else {&#10;                    _uiState.update { it.copy(profileSaveState = SaveState.ERROR, errorMessage = &quot;No se pudo actualizar el perfil.&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(profileSaveState = SaveState.ERROR, errorMessage = &quot;Error de conexión: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Método para cambiar la contraseña del usuario.&#10;    // Actualiza el estado de guardado y maneja errores y éxito.&#10;    fun changePassword(oldPassword: String, newPassword: String, confirmPassword: String) {&#10;        _uiState.update { it.copy(passwordSaveState = SaveState.LOADING, errorMessage = null) }&#10;        viewModelScope.launch {&#10;            try {&#10;                val request = ChangePasswordRequest(oldPassword, newPassword, confirmPassword)&#10;                val response = userRepository.changePassword(request)&#10;                if (response.isSuccessful) {&#10;                    _uiState.update { it.copy(passwordSaveState = SaveState.SUCCESS) }&#10;                } else if (response.code() == 401) {&#10;                    _uiState.update { it.copy(passwordSaveState = SaveState.ERROR, requiresReauthentication = true, errorMessage = &quot;Sesión expirada. Inicia sesión nuevamente.&quot;) }&#10;                } else {&#10;                    _uiState.update { it.copy(passwordSaveState = SaveState.ERROR, errorMessage = &quot;No se pudo cambiar la contraseña.&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(passwordSaveState = SaveState.ERROR, errorMessage = &quot;Error de conexión: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Método para limpiar los estados de guardado y mensajes de error.&#10;    fun clearSaveStates() {&#10;        _uiState.update { it.copy(profileSaveState = SaveState.IDLE, passwordSaveState = SaveState.IDLE, errorMessage = null, requiresReauthentication = false) }&#10;    }&#10;" />
              <option name="updatedContent" value="// ========================================================================&#10;// Archivo: ProfileViewModel.kt&#10;// Propósito: Gestiona el estado y la lógica relacionada con el perfil de usuario.&#10;//            Permite obtener, actualizar el perfil y cambiar la contraseña,&#10;//            manejando los estados de carga, éxito, error y reautenticación.&#10;// ========================================================================&#10;&#10;package com.noskill.anymeal.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.noskill.anymeal.data.local.SessionManager // Importar SessionManager&#10;import com.noskill.anymeal.data.model.User&#10;import com.noskill.anymeal.data.repository.UserRepository&#10;import com.noskill.anymeal.data.di.NetworkModule&#10;import com.noskill.anymeal.dto.ChangePasswordRequest&#10;import com.noskill.anymeal.dto.UpdateProfileRequest&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;&#10;// Define los posibles estados de una operación de guardado (Inactivo, Cargando, Éxito, Error)&#10;enum class SaveState { IDLE, LOADING, SUCCESS, ERROR }&#10;&#10;// El estado de la UI ahora incluye los datos del usuario y los estados de guardado.&#10;data class ProfileUiState(&#10;    val isLoading: Boolean = true,&#10;    val user: User? = null,&#10;    val profileSaveState: SaveState = SaveState.IDLE,&#10;    val passwordSaveState: SaveState = SaveState.IDLE,&#10;    val errorMessage: String? = null,&#10;    val requiresReauthentication: Boolean = false // &lt;-- NUEVO: Bandera para reautenticación&#10;)&#10;&#10;// ProfileViewModel extiende AndroidViewModel y gestiona el estado del perfil de usuario.&#10;class ProfileViewModel(application: Application) : AndroidViewModel(application) {&#10;    // Instancia del servicio de red y repositorio de usuario.&#10;    private val apiService = NetworkModule.provideApiService(application)&#10;    private val userRepository = UserRepository(apiService)&#10;    private val sessionManager = SessionManager(application) // Instancia de SessionManager para manejar el token&#10;&#10;    // StateFlow privado para almacenar el estado de la UI del perfil.&#10;    private val _uiState = MutableStateFlow(ProfileUiState())&#10;    // StateFlow público para observar el estado de la UI desde la interfaz.&#10;    val uiState: StateFlow&lt;ProfileUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Al inicializar el ViewModel, se obtiene el perfil del usuario automáticamente.&#10;    init {&#10;        fetchUserProfile()&#10;    }&#10;&#10;    // Método para obtener el perfil del usuario desde el repositorio.&#10;    // Actualiza el estado según el resultado de la llamada a la API.&#10;    fun fetchUserProfile() {&#10;        _uiState.update { it.copy(isLoading = true, errorMessage = null) }&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userRepository.getUserProfile()&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    _uiState.update { it.copy(isLoading = false, user = response.body()) }&#10;                } else if (response.code() == 401) {&#10;                    // Si el token expiró, se requiere reautenticación&#10;                    _uiState.update { it.copy(isLoading = false, requiresReauthentication = true, errorMessage = &quot;Sesión expirada. Inicia sesión nuevamente.&quot;) }&#10;                } else {&#10;                    _uiState.update { it.copy(isLoading = false, errorMessage = &quot;No se pudo obtener el perfil del usuario.&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(isLoading = false, errorMessage = &quot;Error de conexión: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Método para actualizar el perfil del usuario.&#10;    // Actualiza el estado de guardado y maneja errores y éxito.&#10;    fun updateProfile(username: String, email: String) {&#10;        _uiState.update { it.copy(profileSaveState = SaveState.LOADING, errorMessage = null) }&#10;        viewModelScope.launch {&#10;            try {&#10;                val request = UpdateProfileRequest(username, email)&#10;                val response = userRepository.updateProfile(request)&#10;                if (response.isSuccessful) {&#10;                    _uiState.update { it.copy(profileSaveState = SaveState.SUCCESS) }&#10;                    fetchUserProfile() // Actualiza el perfil en la UI&#10;                } else if (response.code() == 401) {&#10;                    _uiState.update { it.copy(profileSaveState = SaveState.ERROR, requiresReauthentication = true, errorMessage = &quot;Sesión expirada. Inicia sesión nuevamente.&quot;) }&#10;                } else {&#10;                    _uiState.update { it.copy(profileSaveState = SaveState.ERROR, errorMessage = &quot;No se pudo actualizar el perfil.&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(profileSaveState = SaveState.ERROR, errorMessage = &quot;Error de conexión: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Método para cambiar la contraseña del usuario.&#10;    // Actualiza el estado de guardado y maneja errores y éxito.&#10;    fun changePassword(oldPassword: String, newPassword: String, confirmPassword: String) {&#10;        _uiState.update { it.copy(passwordSaveState = SaveState.LOADING, errorMessage = null) }&#10;        viewModelScope.launch {&#10;            try {&#10;                val request = ChangePasswordRequest(oldPassword, newPassword, confirmPassword)&#10;                val response = userRepository.changePassword(request)&#10;                if (response.isSuccessful) {&#10;                    _uiState.update { it.copy(passwordSaveState = SaveState.SUCCESS) }&#10;                } else if (response.code() == 401) {&#10;                    _uiState.update { it.copy(passwordSaveState = SaveState.ERROR, requiresReauthentication = true, errorMessage = &quot;Sesión expirada. Inicia sesión nuevamente.&quot;) }&#10;                } else {&#10;                    _uiState.update { it.copy(passwordSaveState = SaveState.ERROR, errorMessage = &quot;No se pudo cambiar la contraseña.&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(passwordSaveState = SaveState.ERROR, errorMessage = &quot;Error de conexión: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Método para limpiar los estados de guardado y mensajes de error.&#10;    fun clearSaveStates() {&#10;        _uiState.update { it.copy(profileSaveState = SaveState.IDLE, passwordSaveState = SaveState.IDLE, errorMessage = null, requiresReauthentication = false) }&#10;    }&#10;&#10;    // FUNCIONES FALTANTES - Agregadas para solucionar errores en EditProfileScreen&#10;&#10;    // Función para actualizar datos del perfil (alias de updateProfile para compatibilidad)&#10;    fun updateProfileData(username: String, email: String) {&#10;        updateProfile(username, email)&#10;    }&#10;&#10;    // Función para resetear la bandera de reautenticación&#10;    fun resetReauthenticationFlag() {&#10;        _uiState.update { it.copy(requiresReauthentication = false) }&#10;    }&#10;&#10;    // Función para resetear solo los estados de guardado (alias de clearSaveStates)&#10;    fun resetSaveStates() {&#10;        _uiState.update { it.copy(profileSaveState = SaveState.IDLE, passwordSaveState = SaveState.IDLE, errorMessage = null) }&#10;    }&#10;&#10;    // Función para cargar el perfil de usuario (alias de fetchUserProfile)&#10;    fun loadUserProfile() {&#10;        fetchUserProfile()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>