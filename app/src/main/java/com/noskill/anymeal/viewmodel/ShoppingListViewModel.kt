// ========================================================================
// Archivo: ShoppingListViewModel.kt
// Prop√≥sito: Gestiona el estado y la l√≥gica relacionada con la lista de compras.
//            Permite obtener, agregar, editar, actualizar y eliminar elementos
//            de la lista de compras, as√≠ como manejar mensajes de √©xito y error.
// ========================================================================

package com.noskill.anymeal.viewmodel

import android.app.Application
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.noskill.anymeal.data.repository.ShoppingListRepository
import com.noskill.anymeal.data.di.NetworkModule
import com.noskill.anymeal.dto.AddItemRequest
import com.noskill.anymeal.dto.EditItemRequest
import com.noskill.anymeal.dto.GenerateListRequest
import com.noskill.anymeal.ui.models.ShoppingItem
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.*

data class ShoppingListUiState(
    val isLoading: Boolean = true,
    val shoppingList: Map<String, List<ShoppingItem>> = emptyMap(),
    val error: String? = null,
    val successMessage: String? = null
)

// ShoppingListViewModel extiende AndroidViewModel y gestiona el estado de la lista de compras.
class ShoppingListViewModel(application: Application) : AndroidViewModel(application) {

    // Instancia del servicio de red y repositorio de lista de compras.
    private val apiService = NetworkModule.provideApiService(application)
    private val repository = ShoppingListRepository(apiService)

    // StateFlow privado para almacenar el estado de la UI de la lista de compras.
    private val _uiState = MutableStateFlow(ShoppingListUiState())
    // StateFlow p√∫blico que expone el estado de la UI a los observadores.
    val uiState: StateFlow<ShoppingListUiState> = _uiState.asStateFlow()

    // Desplazamiento de semana actual para generar la lista.
    private var currentWeekOffset = 0

    // Genera la lista de compras para la semana especificada por el desplazamiento.
    fun generateListForWeek(weekOffset: Int) {
        currentWeekOffset = weekOffset
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }
            try {
                val (startDate, endDate) = getWeekDateStrings(weekOffset)
                val response = repository.generateAndGetListForWeek(GenerateListRequest(startDate, endDate))
                if (response.isSuccessful && response.body() != null) {
                    val domainModel = response.body()!!.itemsByCategory.mapValues { entry ->
                        entry.value.map { dto ->
                            val quantityStr = listOfNotNull(dto.amount?.toString(), dto.unit).joinToString(" ").trim()
                            ShoppingItem(dto.id, dto.name, quantityStr, dto.category ?: "Otros", dto.isChecked)
                        }
                    }
                    _uiState.update { it.copy(isLoading = false, shoppingList = domainModel) }
                } else {
                    _uiState.update { it.copy(isLoading = false, error = "Error: ${response.code()}") }
                }
            } catch (e: Exception) {
                _uiState.update { it.copy(isLoading = false, error = "Error de conexi√≥n: ${e.message}") }
            }
        }
    }

    // Alterna el estado de verificaci√≥n de un √≠tem en la lista.
    fun toggleItemChecked(itemId: Long) {
        val currentList = _uiState.value.shoppingList
        var itemToUpdate: ShoppingItem? = null

        val updatedMap = currentList.mapValues { (_, items) ->
            items.map { item ->
                if (item.id == itemId) {
                    itemToUpdate = item.copy(isChecked = !item.isChecked)
                    itemToUpdate!!
                } else item
            }
        }
        _uiState.update { it.copy(shoppingList = updatedMap) }

        itemToUpdate?.let { updatedItem ->
            viewModelScope.launch {
                try {
                    repository.updateItem(updatedItem.id, updatedItem.isChecked)
                } catch (e: Exception) {
                    _uiState.update { it.copy(shoppingList = currentList, error = "Error de sincronizaci√≥n") }
                }
            }
        }
    }

    // Limpia los √≠tems marcados como comprados en la lista.
    fun clearCheckedItems() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            try {
                val response = repository.clearCheckedItems()
                if(response.isSuccessful) {
                    generateListForWeek(currentWeekOffset)
                } else {
                    _uiState.update { it.copy(isLoading = false, error = "Error al limpiar") }
                }
            } catch (e: Exception) {
                _uiState.update { it.copy(isLoading = false, error = "Error de conexi√≥n") }
            }
        }
    }

    // Agrega un nuevo √≠tem a la lista de compras.
    fun addItem(name: String, quantity: String) {
        Log.d("ShoppingListVM", "üü¢ ADD_ITEM: Iniciando - name='$name', quantity='$quantity'")
        viewModelScope.launch {
            try {
                val parts = quantity.split(" ")
                val amount = parts.firstOrNull()?.toDoubleOrNull()
                val unit = if (parts.size > 1) parts.drop(1).joinToString(" ") else null

                val request = AddItemRequest(name, amount, unit, "A√±adido manualmente")
                Log.d("ShoppingListVM", "üü¢ ADD_ITEM: Request creado - $request")

                val response = repository.addItem(request)
                Log.d("ShoppingListVM", "üü¢ ADD_ITEM: Response recibido - isSuccessful=${response.isSuccessful}, code=${response.code()}")

                if (response.isSuccessful) {
                    Log.d("ShoppingListVM", "üü¢ ADD_ITEM: ‚úÖ √âxito! Llamando getCurrentList()")
                    getCurrentList()
                    _uiState.update { it.copy(successMessage = "√çtem '$name' a√±adido correctamente") }
                } else {
                    val errorMsg = when (response.code()) {
                        400 -> "Datos inv√°lidos. Verifica el nombre y cantidad."
                        401 -> "Sesi√≥n expirada. Inicia sesi√≥n nuevamente."
                        500 -> "Error del servidor. Intenta m√°s tarde."
                        else -> "No se pudo a√±adir el √≠tem (${response.code()})"
                    }
                    Log.e("ShoppingListVM", "üü¢ ADD_ITEM: ‚ùå Error HTTP - $errorMsg")
                    _uiState.update { it.copy(error = errorMsg) }
                }
            } catch (e: Exception) {
                Log.e("ShoppingListVM", "üü¢ ADD_ITEM: ‚ùå Excepci√≥n - ${e.localizedMessage}", e)
                _uiState.update { it.copy(error = "Error de conexi√≥n: ${e.localizedMessage}") }
            }
        }
    }

    // Limpia los mensajes de error y √©xito en el estado de la UI.
    fun clearError() {
        _uiState.update { it.copy(error = null, successMessage = null) }
    }

    // Deselecciona un √≠tem en la lista (lo desmarca como comprado).
    fun unselectItem(itemId: Long) {
        val currentList = _uiState.value.shoppingList
        val updatedMap = currentList.mapValues { (_, items) ->
            items.map { item ->
                if (item.id == itemId) {
                    item.copy(isChecked = false)
                } else item
            }
        }
        _uiState.update { it.copy(shoppingList = updatedMap) }
    }

    // Elimina un √≠tem de la lista de compras.
    fun deleteItem(itemId: Long) {
        Log.d("ShoppingListVM", "üî¥ DELETE_ITEM: Iniciando - itemId=$itemId")
        viewModelScope.launch {
            try {
                // Eliminar directamente del backend sin desmarcar primero
                Log.d("ShoppingListVM", "üî¥ DELETE_ITEM: Eliminando del backend")
                val deleteResponse = repository.deleteItem(itemId)
                Log.d("ShoppingListVM", "üî¥ DELETE_ITEM: Response delete: isSuccessful=${deleteResponse.isSuccessful}, code=${deleteResponse.code()}")

                if (deleteResponse.isSuccessful) {
                    Log.d("ShoppingListVM", "üî¥ DELETE_ITEM: ‚úÖ √âxito! Llamando getCurrentList()")
                    getCurrentList()
                    _uiState.update { it.copy(successMessage = "√çtem eliminado correctamente") }
                } else {
                    val errorMsg = when (deleteResponse.code()) {
                        404 -> "El √≠tem no existe o ya fue eliminado."
                        401 -> "Sesi√≥n expirada. Inicia sesi√≥n nuevamente."
                        403 -> "No tienes permisos para eliminar este √≠tem."
                        500 -> "Error del servidor. Intenta m√°s tarde."
                        else -> "No se pudo eliminar el √≠tem (${deleteResponse.code()})"
                    }
                    Log.e("ShoppingListVM", "üî¥ DELETE_ITEM: ‚ùå Error HTTP - $errorMsg")
                    _uiState.update { it.copy(error = errorMsg) }
                }
            } catch (e: Exception) {
                Log.e("ShoppingListVM", "üî¥ DELETE_ITEM: ‚ùå Excepci√≥n - ${e.localizedMessage}", e)
                _uiState.update { it.copy(error = "Error de conexi√≥n al eliminar: ${e.localizedMessage}") }
            }
        }
    }

    // Edita un √≠tem existente en la lista de compras.
    fun editItem(itemId: Long, name: String, quantity: String) {
        Log.d("ShoppingListVM", "üîµ EDIT_ITEM: Iniciando - itemId=$itemId, name='$name', quantity='$quantity'")
        viewModelScope.launch {
            try {
                // Preparar los datos para editar
                val parts = quantity.split(" ")
                val amount = parts.firstOrNull()?.toDoubleOrNull()
                val unit = if (parts.size > 1) parts.drop(1).joinToString(" ") else null

                val request = EditItemRequest(name, amount, unit)
                Log.d("ShoppingListVM", "üîµ EDIT_ITEM: Request preparado: $request")

                // Editar directamente en el backend
                Log.d("ShoppingListVM", "üîµ EDIT_ITEM: Enviando edici√≥n al backend")
                val editResponse = repository.editItem(itemId, request)
                Log.d("ShoppingListVM", "üîµ EDIT_ITEM: Response edit: isSuccessful=${editResponse.isSuccessful}, code=${editResponse.code()}")

                if (editResponse.isSuccessful) {
                    Log.d("ShoppingListVM", "üîµ EDIT_ITEM: ‚úÖ √âxito! Llamando getCurrentList()")
                    getCurrentList()
                    _uiState.update { it.copy(successMessage = "√çtem editado correctamente") }
                } else {
                    val errorMsg = when (editResponse.code()) {
                        400 -> "Datos inv√°lidos. Verifica el nombre y cantidad."
                        401 -> "Sesi√≥n expirada. Inicia sesi√≥n nuevamente."
                        403 -> "No tienes permisos para editar este √≠tem."
                        404 -> "El √≠tem no existe o ya fue eliminado."
                        500 -> "Error del servidor. Intenta m√°s tarde."
                        else -> "No se pudo editar el √≠tem (${editResponse.code()})"
                    }
                    Log.e("ShoppingListVM", "üîµ EDIT_ITEM: ‚ùå Error HTTP - $errorMsg")
                    _uiState.update { it.copy(error = errorMsg) }
                }
            } catch (e: Exception) {
                Log.e("ShoppingListVM", "üîµ EDIT_ITEM: ‚ùå Excepci√≥n - ${e.localizedMessage}", e)
                _uiState.update { it.copy(error = "Error de conexi√≥n al editar: ${e.localizedMessage}") }
            }
        }
    }

    // Obtiene la lista de compras actual del usuario.
    fun getCurrentList() {
        Log.d("ShoppingListVM", "üìã GET_CURRENT_LIST: Iniciando")
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }
            try {
                val response = repository.getCurrentShoppingList()
                Log.d("ShoppingListVM", "üìã GET_CURRENT_LIST: Response recibido - isSuccessful=${response.isSuccessful}, code=${response.code()}")

                if (response.isSuccessful && response.body() != null) {
                    val itemCount = response.body()!!.itemsByCategory.values.sumOf { it.size }
                    Log.d("ShoppingListVM", "üìã GET_CURRENT_LIST: ‚úÖ √âxito! Items encontrados: $itemCount")

                    val domainModel = response.body()!!.itemsByCategory.mapValues { entry ->
                        entry.value.map { dto ->
                            val quantityStr = listOfNotNull(dto.amount?.toString(), dto.unit).joinToString(" ").trim()
                            ShoppingItem(dto.id, dto.name, quantityStr, dto.category ?: "Otros", dto.isChecked)
                        }
                    }
                    _uiState.update { it.copy(isLoading = false, shoppingList = domainModel) }
                } else {
                    Log.e("ShoppingListVM", "üìã GET_CURRENT_LIST: ‚ùå Error HTTP - code=${response.code()}")
                    _uiState.update { it.copy(isLoading = false, error = "Error: ${response.code()}") }
                }
            } catch (e: Exception) {
                Log.e("ShoppingListVM", "üìã GET_CURRENT_LIST: ‚ùå Excepci√≥n - ${e.localizedMessage}", e)
                _uiState.update { it.copy(isLoading = false, error = "Error de conexi√≥n: ${e.message}") }
            }
        }
    }


    // Funci√≥n privada que obtiene las fechas de inicio y fin de la semana para el desplazamiento dado.
    private fun getWeekDateStrings(weekOffset: Int): Pair<String, String> {
        val formatter = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        val calendar = Calendar.getInstance().apply {
            add(Calendar.WEEK_OF_YEAR, weekOffset)
            set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)
        }
        val startDate = formatter.format(calendar.time)
        calendar.add(Calendar.DAY_OF_YEAR, 6)
        val endDate = formatter.format(calendar.time)
        return Pair(startDate, endDate)
    }
}